{"version":3,"sources":["../src/WebSocketTransport.js"],"names":["WebSocket","global","require","WebSocketTransport","url","Promise","resolve","reject","socket","exchangeMethods","resolveExchange","_b","rejectExchange","_e","onDisconnect","close","send","msg","onopen","onerror","e","onclose","onmessage","data","JSON","parse","type","Error","error","Buffer","from","hook","emit","apdu","hex","toString","b","res","setTimeout","success","isSupported","list","listen","_observer","unsubscribe","check","timeout"],"mappings":"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","file":"WebSocketTransport.js","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport { log } from \"@ledgerhq/logs\";\n\nconst WebSocket = global.WebSocket || require(\"ws\");\n\n/**\n * WebSocket transport implementation\n */\nexport default class WebSocketTransport extends Transport<string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof WebSocket === \"function\");\n\n  // this transport is not discoverable\n  static list = (): * => Promise.resolve([]);\n  static listen = (_observer: *) => ({\n    unsubscribe: () => {}\n  });\n\n  static check = async (url: string, timeout: number = 5000) =>\n    new Promise((resolve, reject) => {\n      const socket = new WebSocket(url);\n      let success = false;\n      setTimeout(() => {\n        socket.close();\n      }, timeout);\n      socket.onopen = () => {\n        success = true;\n        socket.close();\n      };\n      socket.onclose = () => {\n        if (success) resolve();\n        else {\n          reject(\n            new TransportError(\n              \"failed to access WebSocketTransport(\" + url + \")\",\n              \"WebSocketTransportNotAccessible\"\n            )\n          );\n        }\n      };\n      socket.onerror = () => {\n        reject(\n          new TransportError(\n            \"failed to access WebSocketTransport(\" + url + \"): error\",\n            \"WebSocketTransportNotAccessible\"\n          )\n        );\n      };\n    });\n\n  static async open(url: string) {\n    const exchangeMethods = await new Promise((resolve, reject) => {\n      try {\n        const socket = new WebSocket(url);\n        const exchangeMethods = {\n          resolveExchange: (_b: Buffer) => {},\n          rejectExchange: (_e: *) => {},\n          onDisconnect: () => {},\n          close: () => socket.close(),\n          send: msg => socket.send(msg)\n        };\n        socket.onopen = () => {\n          socket.send(\"open\");\n        };\n        socket.onerror = e => {\n          exchangeMethods.onDisconnect();\n          reject(e);\n        };\n        socket.onclose = () => {\n          exchangeMethods.onDisconnect();\n          reject(new TransportError(\"OpenFailed\", \"OpenFailed\"));\n        };\n        socket.onmessage = e => {\n          if (typeof e.data !== \"string\") return;\n          const data = JSON.parse(e.data);\n          switch (data.type) {\n            case \"opened\":\n              return resolve(exchangeMethods);\n            case \"error\":\n              reject(new Error(data.error));\n              return exchangeMethods.rejectExchange(\n                new TransportError(data.error, \"WSError\")\n              );\n            case \"response\":\n              return exchangeMethods.resolveExchange(\n                Buffer.from(data.data, \"hex\")\n              );\n          }\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n    return new WebSocketTransport(exchangeMethods);\n  }\n\n  hook: *;\n\n  constructor(hook: *) {\n    super();\n    this.hook = hook;\n    hook.onDisconnect = () => {\n      this.emit(\"disconnect\");\n      this.hook.rejectExchange(\n        new TransportError(\"WebSocket disconnected\", \"WSDisconnect\")\n      );\n    };\n  }\n\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    const hex = apdu.toString(\"hex\");\n    log(\"apdu\", \"=> \" + hex);\n    const res = await new Promise((resolve, reject) => {\n      this.hook.rejectExchange = (e: *) => reject(e);\n      this.hook.resolveExchange = (b: Buffer) => resolve(b);\n      this.hook.send(hex);\n    });\n    log(\"apdu\", \"<= \" + res.toString(\"hex\"));\n    return res;\n  }\n\n  setScrambleKey() {}\n\n  async close() {\n    this.hook.close();\n    return new Promise(success => {\n      setTimeout(success, 200);\n    });\n  }\n}\n"]}